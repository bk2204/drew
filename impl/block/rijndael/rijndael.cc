/*-
 * Copyright © 2000-2009 The Legion Of The Bouncy Castle
 * (http://www.bouncycastle.org)
 * Copyright © 2010 brian m. carlson
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
/* This has been ported from the Java version written by the Legion of the
 * Bouncy Castle.  This implementation supports arbitrary block sizes and
 * arbitrary key sizes, unlike the version in the aes directory.
 */

#include <internal.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <algorithm>

#include <block.h>
#include "block-plugin.h"
#include "rijndael.hh"


extern "C" {

static const int rd_keysz[] =
{
	16, 20, 24, 28, 32
};


static const int rd_aes128_keysz[] = {16};
static const int rd_aes192_keysz[] = {24};
static const int rd_aes256_keysz[] = {32};

#define DIM(x) (sizeof(x)/sizeof(x[0]))

static int rd_main_info(int op, void *p, size_t blksz, const int *keysz,
		size_t nkeysz)
{
	switch (op) {
		case DREW_BLOCK_VERSION:
			return 0;
		case DREW_BLOCK_BLKSIZE:
			return blksz;
		case DREW_BLOCK_KEYSIZE:
			for (size_t i = 0; i < nkeysz; i++) {
				const int *x = reinterpret_cast<int *>(p);
				if (keysz[i] > *x)
					return keysz[i];
			}
			return 0;
		case DREW_BLOCK_INTSIZE:
			return sizeof(drew::Rijndael);
		default:
			return -EINVAL;
	}
}

static int rd_info(int op, void *p)
{
	return rd_main_info(op, p, 16, rd_keysz, DIM(rd_keysz));
}

static int rd160_info(int op, void *p)
{
	return rd_main_info(op, p, 20, rd_keysz, DIM(rd_keysz));
}

static int rd192_info(int op, void *p)
{
	return rd_main_info(op, p, 24, rd_keysz, DIM(rd_keysz));
}

static int rd224_info(int op, void *p)
{
	return rd_main_info(op, p, 28, rd_keysz, DIM(rd_keysz));
}

static int rd256_info(int op, void *p)
{
	return rd_main_info(op, p, 32, rd_keysz, DIM(rd_keysz));
}

static int rd_aes128_info(int op, void *p)
{
	return rd_main_info(op, p, 16, rd_aes128_keysz, DIM(rd_aes128_keysz));
}

static int rd_aes192_info(int op, void *p)
{
	return rd_main_info(op, p, 16, rd_aes192_keysz, DIM(rd_aes192_keysz));
}

static int rd_aes256_info(int op, void *p)
{
	return rd_main_info(op, p, 16, rd_aes256_keysz, DIM(rd_aes256_keysz));
}

static void rd_main_init(void **ctx, size_t blksz)
{
	drew::Rijndael *p = 0;
	switch (blksz)
	{
		case 16:
			p = new drew::Rijndael128;
			break;
		case 20:
			p = new drew::Rijndael160;
			break;
		case 24:
			p = new drew::Rijndael192;
			break;
		case 28:
			p = new drew::Rijndael224;
			break;
		case 32:
			p = new drew::Rijndael256;
			break;
	}
	*ctx = p;
}

static void rd_aes_init(void **ctx, drew_loader_t *, const drew_param_t *)
{
	return rd_main_init(ctx, 16);
}

static void rd160_init(void **ctx, drew_loader_t *, const drew_param_t *)
{
	return rd_main_init(ctx, 20);
}

static void rd192_init(void **ctx, drew_loader_t *, const drew_param_t *)
{
	return rd_main_init(ctx, 24);
}

static void rd224_init(void **ctx, drew_loader_t *, const drew_param_t *)
{
	return rd_main_init(ctx, 28);
}

static void rd256_init(void **ctx, drew_loader_t *, const drew_param_t *)
{
	return rd_main_init(ctx, 32);
}

static int rd_clone(void **newctx, void *oldctx, int flags)
{
	using namespace drew;
	Rijndael *p = 0, *x = reinterpret_cast<Rijndael *>(oldctx);
	switch (x->GetBlockSize())
	{
		case 16:
			p = new Rijndael128(*reinterpret_cast<Rijndael128 *>(x));
			break;
		case 20:
			p = new Rijndael160(*reinterpret_cast<Rijndael160 *>(x));
			break;
		case 24:
			p = new Rijndael192(*reinterpret_cast<Rijndael192 *>(x));
			break;
		case 28:
			p = new Rijndael224(*reinterpret_cast<Rijndael224 *>(x));
			break;
		case 32:
			p = new Rijndael256(*reinterpret_cast<Rijndael256 *>(x));
			break;
	}
	if (flags & DREW_BLOCK_CLONE_FIXED) {
		memcpy(*newctx, p, sizeof(*p));
		delete p;
	}
	else
		*newctx = p;
	return 0;
}

static int rd_setkey(void *ctx, const uint8_t *key, size_t len)
{
	drew::Rijndael *p = reinterpret_cast<drew::Rijndael *>(ctx);
	p->SetKey(key, len);
	return 0;
}

static void rd_encrypt(void *ctx, uint8_t *out, const uint8_t *in)
{
	drew::Rijndael *p = reinterpret_cast<drew::Rijndael *>(ctx);
	p->Encrypt(out, in);
}

static void rd_decrypt(void *ctx, uint8_t *out, const uint8_t *in)
{
	drew::Rijndael *p = reinterpret_cast<drew::Rijndael *>(ctx);
	p->Decrypt(out, in);
}

static void rd_fini(void **ctx)
{
	drew::Rijndael *p = reinterpret_cast<drew::Rijndael *>(*ctx);
	delete p;
	*ctx = NULL;
}

static void str2bytes(uint8_t *bytes, const char *s, size_t len = 0)
{
	if (!len)
		len = strlen(s);

	unsigned x;
	for (size_t i = 0; i < (len / 2); i++) {
		sscanf(s+(i*2), "%02x", &x);
		bytes[i] = x;
	}
}

static bool test(const char *key, const char *plain, const char *cipher,
		size_t keybytes = 0, size_t blocksz = 16)
{
	using namespace drew;

	uint8_t kb[32], pb[32], cb[32], buf[32];
	str2bytes(kb, key, keybytes * 2);
	str2bytes(pb, plain, blocksz * 2);
	str2bytes(cb, cipher, blocksz * 2);

	if (!keybytes)
		keybytes = 16;

	void *p;
	rd_main_init(&p, blocksz);
	Rijndael *ctx = reinterpret_cast<Rijndael *>(p);
	ctx->SetKey(kb, keybytes);
	ctx->Encrypt(buf, pb);

	if (memcmp(buf, cb, blocksz))
		return false;

	ctx->SetKey(kb, keybytes);
	ctx->Decrypt(buf, cb);
	rd_fini(&p);

	return !memcmp(buf, pb, blocksz);
}

static int rd_test(void *)
{
	int res = 0;

	const char *key =
		"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f";
	const char *pt = "00112233445566778899aabbccddeeff";
	res |= !test(key, pt, "69c4e0d86a7b0430d8cdb78070b4c55a", 16);
	res |= !test(key, pt, "dda97ca4864cdfe06eaf70a0ec0d7191", 24);
	res |= !test(key, pt, "8ea2b7ca516745bfeafc49904b496089", 32);
	res <<= 1;
	const char *key2 = "2b7e151628aed2a6abf7158809cf4f3c";
	const char *pt1 = "6bc1bee22e409f96e93d7e117393172a";
	const char *pt2 = "ae2d8a571e03ac9c9eb76fac45af8e51";
	const char *pt3 = "30c81c46a35ce411e5fbc1191a0a52ef";
	const char *pt4 = "f69f2445df4f9b17ad2b417be66c3710";
	res |= !test(key2, pt1, "3ad77bb40d7a3660a89ecaf32466ef97");
	res |= !test(key2, pt2, "f5d3d58503b9699de785895a96fdbaaf");
	res |= !test(key2, pt3, "43b1cd7f598ece23881b00e3ed030688");
	res |= !test(key2, pt4, "7b0c785e27e8ad3f8223207104725dd4");
	res <<= 1;
	const char *key3 = "8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b";
	res |= !test(key3, pt1, "bd334f1d6e45f25ff712a214571fa5cc", 24);
	res |= !test(key3, pt2, "974104846d0ad3ad7734ecb3ecee4eef", 24);
	res |= !test(key3, pt3, "ef7afd2270e2e60adce0ba2face6444e", 24);
	res |= !test(key3, pt4, "9a4b41ba738d6c72fb16691603c18e0e", 24);
	res <<= 1;
	const char *key4 =
		"603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4";
	res |= !test(key4, pt1, "f3eed1bdb5d2a03c064b5a7e3db181f8", 32);
	res |= !test(key4, pt2, "591ccb10d410ed26dc5ba74a31362870", 32);
	res |= !test(key4, pt3, "b6ed21b99ca6f4f9f153e7b1beafed1d", 32);
	res |= !test(key4, pt4, "23304b7a39f9f3ff067d8d8f9e24ecc7", 32);
	res <<= 1;

	const char *key5 =
		"2b7e151628aed2a6abf7158809cf4f3c762e7160f38b4da56a784d9045190cfe";
	const char *blk = 
		"3243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e6c8";
	res |= !test(key5, blk, "3925841d02dc09fbdc118597196a0b32", 16, 16);
	res |= !test(key5, blk, "231d844639b31b412211cfe93712b880", 20, 16);
	res |= !test(key5, blk, "f9fb29aefc384a250340d833b87ebc00", 24, 16);
	res |= !test(key5, blk, "8faa8fe4dee9eb17caa4797502fc9d3f", 28, 16);
	res |= !test(key5, blk, "1a6e6c2c662e7da6501ffb62bc9e93f3", 32, 16);
	res <<= 1;

	res |= !test(key5, blk, "16e73aec921314c29df905432bc8968ab64b1f51", 16, 20);
	res |= !test(key5, blk, "0553eb691670dd8a5a5b5addf1aa7450f7a0e587", 20, 20);
	res |= !test(key5, blk, "73cd6f3423036790463aa9e19cfcde894ea16623", 24, 20);
	res |= !test(key5, blk, "601b5dcd1cf4ece954c740445340bf0afdc048df", 28, 20);
	res |= !test(key5, blk, "579e930b36c1529aa3e86628bacfe146942882cf", 32, 20);
	res <<= 1;

	res |= !test(key5, blk, "b24d275489e82bb8f7375e0d5fcdb1f481757c538b65148a",
			16, 24);
	res |= !test(key5, blk, "738dae25620d3d3beff4a037a04290d73eb33521a63ea568",
			20, 24);
	res |= !test(key5, blk, "725ae43b5f3161de806a7c93e0bca93c967ec1ae1b71e1cf",
			24, 24);
	res |= !test(key5, blk, "bbfc14180afbf6a36382a061843f0b63e769acdc98769130",
			28, 24);
	res |= !test(key5, blk, "0ebacf199e3315c2e34b24fcc7c46ef4388aa475d66c194c",
			32, 24);
	res <<= 1;

	res |= !test(key5, blk,
			"b0a8f78f6b3c66213f792ffd2a61631f79331407a5e5c8d3793aceb1", 16, 28);
	res |= !test(key5, blk,
			"08b99944edfce33a2acb131183ab0168446b2d15e958480010f545e3", 20, 28);
	res |= !test(key5, blk,
			"be4c597d8f7efe22a2f7e5b1938e2564d452a5bfe72399c7af1101e2", 24, 28);
	res |= !test(key5, blk,
			"ef529598ecbce297811b49bbed2c33bbe1241d6e1a833dbe119569e8", 28, 28);
	res |= !test(key5, blk,
			"02fafc200176ed05deb8edb82a3555b0b10d47a388dfd59cab2f6c11", 32, 28);
	res <<= 1;

	res |= !test(key5, blk,
			"7d15479076b69a46ffb3b3beae97ad8313f622f67fedb487de9f06b9ed9c8f19",
			16, 32);
	res |= !test(key5, blk,
			"514f93fb296b5ad16aa7df8b577abcbd484decacccc7fb1f18dc567309ceeffd",
			20, 32);
	res |= !test(key5, blk,
			"5d7101727bb25781bf6715b0e6955282b9610e23a43c2eb062699f0ebf5887b2",
			24, 32);
	res |= !test(key5, blk,
			"d56c5a63627432579e1dd308b2c8f157b40a4bfb56fea1377b25d3ed3d6dbf80",
			28, 32);
	res |= !test(key5, blk,
			"a49406115dfb30a40418aafa4869b7c6a886ff31602a7dd19c889dc64f7e4e7a",
			32, 32);

	return res;
}

	PLUGIN_FUNCTBL(rijndael, rd_info, rd_aes_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(rijndael160, rd160_info, rd160_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(rijndael192, rd192_info, rd192_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(rijndael224, rd224_info, rd224_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(rijndael256, rd256_info, rd256_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(aes128, rd_aes128_info, rd_aes_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(aes192, rd_aes192_info, rd_aes_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_FUNCTBL(aes256, rd_aes256_info, rd_aes_init, rd_setkey, rd_encrypt, rd_decrypt, rd_test, rd_fini, rd_clone);
	PLUGIN_DATA_START()
	PLUGIN_DATA(rijndael, "Rijndael")
	PLUGIN_DATA(rijndael160, "Rijndael-160")
	PLUGIN_DATA(rijndael192, "Rijndael-192")
	PLUGIN_DATA(rijndael224, "Rijndael-224")
	PLUGIN_DATA(rijndael256, "Rijndael-256")
	PLUGIN_DATA(aes128, "AES128")
	PLUGIN_DATA(aes192, "AES192")
	PLUGIN_DATA(aes256, "AES256")
	PLUGIN_DATA_END()
	PLUGIN_INTERFACE()
}

typedef drew::Rijndael::endian_t E;

drew::Rijndael::Rijndael()
{
}

#define MAXNK 8

template<unsigned N>
void drew::GenericRijndael<N>::SetKey(const uint8_t *key, size_t len)
{
	m_nk = (len / 4);
	m_nr = 6 + std::max(m_nb, m_nk);

	uint8_t tk[4][MAXNK];

	for (size_t i = 0; i < len; i++) {
	    tk[i % 4][i / 4] = key[i];
	}

	size_t t = 0;

	memset(m_rk, 0, sizeof(m_rk));

	for (size_t j = 0; (j < m_nk) && (t < (m_nr+1)*m_nb); j++, t++) {
		for (size_t i = 0; i < 4; i++) {
			m_rk[t / m_nb][i] |=
				uint64_t(tk[i][j] & 0xff) << ((t * 8) % m_bc); 
		}
	}

	int ri = 0;

	while (t < (m_nr+1)*m_nb) {
		for (size_t i = 0; i < 4; i++)
			tk[i][0] ^= S[tk[(i+1)%4][m_nk-1] & 0xff];
		tk[0][0] ^= rcon[ri++];

		if (m_nk <= 6)
			for (size_t j = 1; j < m_nk; j++)
				for (size_t i = 0; i < 4; i++)
					tk[i][j] ^= tk[i][j-1];
		else {
			for (size_t j = 1; j < 4; j++)
				for (int i = 0; i < 4; i++)
					tk[i][j] ^= tk[i][j-1];
			for (size_t i = 0; i < 4; i++)
				tk[i][4] ^= S[tk[i][3] & 0xff];
			for (size_t j = 5; j < m_nk; j++)
				for (size_t i = 0; i < 4; i++)
					tk[i][j] ^= tk[i][j-1];
		}
		for (size_t j = 0; (j < m_nk) && (t < (m_nr+1)*m_nb); j++, t++) {
			for (size_t i = 0; i < 4; i++) {
				m_rk[t / m_nb][i] |= 
					uint64_t(tk[i][j] & 0xff) << ((t * 8) % (m_bc));
			}
		}
	}
}

void drew::Rijndael128::SetKey(const uint8_t *key, size_t len)
{
	drew::GenericRijndael<128>::SetKey(key, len);
	const size_t rksz = sizeof(uint64_t) * 4;
	uint8_t *rk = m_rkb;
	for (size_t i = 0; i < m_nr+1; i++, rk += rksz)
		E::Copy(rk, m_rk[i], rksz);
}

void drew::Rijndael::Encrypt(uint8_t *out, const uint8_t *in)
{
	uint64_t state[4];
	memset(state, 0, sizeof(state));

	UnpackBlock(state, in);
	EncryptBlock(state);
	PackBlock(out, state);
}

void drew::Rijndael::Decrypt(uint8_t *out, const uint8_t *in)
{
	uint64_t state[4];
	memset(state, 0, sizeof(state));

	UnpackBlock(state, in);
	DecryptBlock(state);
	PackBlock(out, state);
}

void drew::Rijndael128::Encrypt(uint8_t *out, const uint8_t *in)
{
	memcpy(out, in, block_size);
	EncryptBlock(out);
}


const uint8_t drew::Rijndael::shifts0[5][4] = {
   { 0, 8, 16, 24 },
   { 0, 8, 16, 24 },
   { 0, 8, 16, 24 },
   { 0, 8, 16, 32 },
   { 0, 8, 24, 32 }
};

const uint8_t drew::Rijndael::shifts1[5][4] = {
   { 0, 24, 16, 8 },
   { 0, 32, 24, 16 },
   { 0, 40, 32, 24 },
   { 0, 48, 40, 24 },
   { 0, 56, 40, 32 }
};


void drew::Rijndael::KeyAddition(uint64_t *state, const uint64_t *rk)
{
	state[0] ^= rk[0];
	state[1] ^= rk[1];
	state[2] ^= rk[2];
	state[3] ^= rk[3];
}

template<unsigned N>
void drew::GenericRijndael<N>::ShiftRow(uint64_t *state, const uint8_t *shifts)
{
	state[1] = shift(state[1], shifts[1]);
	state[2] = shift(state[2], shifts[2]);
	state[3] = shift(state[3], shifts[3]);
}

void drew::Rijndael::Substitution(uint64_t *state, const uint8_t *box)
{
	state[0] = ApplyS(state[0], box);
	state[1] = ApplyS(state[1], box);
	state[2] = ApplyS(state[2], box);
	state[3] = ApplyS(state[3], box);
}

template<unsigned N>
uint64_t drew::GenericRijndael<N>::ApplyS(uint64_t r, const uint8_t *box)
{
	uint64_t res = 0;

	for (int i = 7; i >= 0; i--) {
		res <<= 8;
		res |= uint64_t(box[E::GetByte(r, i)]);
	}
	res &= m_bcmask;

	return res;
}

void drew::Rijndael128::Modify(uint64_t *state, const uint8_t *box)
{
	uint64_t a = state[0], b = state[1], c = state[2], d = state[3];

	a = (box[E::GetByte(a, 3)] << 24) |
		(box[E::GetByte(a, 2)] << 16) |
		(box[E::GetByte(a, 1)] <<  8) |
		(box[E::GetByte(a, 0)]);
	b = (box[E::GetByte(b, 0)] << 24) |
		(box[E::GetByte(b, 3)] << 16) |
		(box[E::GetByte(b, 2)] <<  8) |
		(box[E::GetByte(b, 1)]);
	c = (box[E::GetByte(c, 1)] << 24) |
		(box[E::GetByte(c, 0)] << 16) |
		(box[E::GetByte(c, 3)] <<  8) |
		(box[E::GetByte(c, 2)]);
	d = (box[E::GetByte(d, 2)] << 24) |
		(box[E::GetByte(d, 1)] << 16) |
		(box[E::GetByte(d, 0)] <<  8) |
		(box[E::GetByte(d, 3)]);

	state[0] = a;
	state[1] = b;
	state[2] = c;
	state[3] = d;
}

void drew::Rijndael160::Modify(uint64_t *state, const uint8_t *box)
{
	uint64_t a = state[0], b = state[1], c = state[2], d = state[3];

	a = uint64_t(box[E::GetByte(a, 4)]) << 32 |
		uint64_t(box[E::GetByte(a, 3)]) << 24 |
		uint64_t(box[E::GetByte(a, 2)]) << 16 |
		uint64_t(box[E::GetByte(a, 1)]) <<  8 |
		uint64_t(box[E::GetByte(a, 0)]);
	b = uint64_t(box[E::GetByte(b, 0)]) << 32 |
		uint64_t(box[E::GetByte(b, 4)]) << 24 |
		uint64_t(box[E::GetByte(b, 3)]) << 16 |
		uint64_t(box[E::GetByte(b, 2)]) <<  8 |
		uint64_t(box[E::GetByte(b, 1)]);
	c = uint64_t(box[E::GetByte(c, 1)]) << 32 |
		uint64_t(box[E::GetByte(c, 0)]) << 24 |
		uint64_t(box[E::GetByte(c, 4)]) << 16 |
		uint64_t(box[E::GetByte(c, 3)]) <<  8 |
		uint64_t(box[E::GetByte(c, 2)]);
	d = uint64_t(box[E::GetByte(d, 2)]) << 32 |
		uint64_t(box[E::GetByte(d, 1)]) << 24 |
		uint64_t(box[E::GetByte(d, 0)]) << 16 |
		uint64_t(box[E::GetByte(d, 4)]) <<  8 |
		uint64_t(box[E::GetByte(d, 3)]);

	state[0] = a;
	state[1] = b;
	state[2] = c;
	state[3] = d;
}

void drew::Rijndael192::Modify(uint64_t *state, const uint8_t *box)
{
	uint64_t a = state[0], b = state[1], c = state[2], d = state[3];

	a = uint64_t(box[E::GetByte(a, 5)]) << 40 |
		uint64_t(box[E::GetByte(a, 4)]) << 32 |
		uint64_t(box[E::GetByte(a, 3)]) << 24 |
		uint64_t(box[E::GetByte(a, 2)]) << 16 |
		uint64_t(box[E::GetByte(a, 1)]) <<  8 |
		uint64_t(box[E::GetByte(a, 0)]);
	b = uint64_t(box[E::GetByte(b, 0)]) << 40 |
		uint64_t(box[E::GetByte(b, 5)]) << 32 |
		uint64_t(box[E::GetByte(b, 4)]) << 24 |
		uint64_t(box[E::GetByte(b, 3)]) << 16 |
		uint64_t(box[E::GetByte(b, 2)]) <<  8 |
		uint64_t(box[E::GetByte(b, 1)]);
	c = uint64_t(box[E::GetByte(c, 1)]) << 40 |
		uint64_t(box[E::GetByte(c, 0)]) << 32 |
		uint64_t(box[E::GetByte(c, 5)]) << 24 |
		uint64_t(box[E::GetByte(c, 4)]) << 16 |
		uint64_t(box[E::GetByte(c, 3)]) <<  8 |
		uint64_t(box[E::GetByte(c, 2)]);
	d = uint64_t(box[E::GetByte(d, 2)]) << 40 |
		uint64_t(box[E::GetByte(d, 1)]) << 32 |
		uint64_t(box[E::GetByte(d, 0)]) << 24 |
		uint64_t(box[E::GetByte(d, 5)]) << 16 |
		uint64_t(box[E::GetByte(d, 4)]) <<  8 |
		uint64_t(box[E::GetByte(d, 3)]);

	state[0] = a;
	state[1] = b;
	state[2] = c;
	state[3] = d;
}

void drew::Rijndael224::Modify(uint64_t *state, const uint8_t *box)
{
	uint64_t a = state[0], b = state[1], c = state[2], d = state[3];

	a = uint64_t(box[E::GetByte(a, 6)]) << 48 |
		uint64_t(box[E::GetByte(a, 5)]) << 40 |
		uint64_t(box[E::GetByte(a, 4)]) << 32 |
		uint64_t(box[E::GetByte(a, 3)]) << 24 |
		uint64_t(box[E::GetByte(a, 2)]) << 16 |
		uint64_t(box[E::GetByte(a, 1)]) <<  8 |
		uint64_t(box[E::GetByte(a, 0)]);
	b = uint64_t(box[E::GetByte(b, 0)]) << 48 |
		uint64_t(box[E::GetByte(b, 6)]) << 40 |
		uint64_t(box[E::GetByte(b, 5)]) << 32 |
		uint64_t(box[E::GetByte(b, 4)]) << 24 |
		uint64_t(box[E::GetByte(b, 3)]) << 16 |
		uint64_t(box[E::GetByte(b, 2)]) <<  8 |
		uint64_t(box[E::GetByte(b, 1)]);
	c = uint64_t(box[E::GetByte(c, 1)]) << 48 |
		uint64_t(box[E::GetByte(c, 0)]) << 40 |
		uint64_t(box[E::GetByte(c, 6)]) << 32 |
		uint64_t(box[E::GetByte(c, 5)]) << 24 |
		uint64_t(box[E::GetByte(c, 4)]) << 16 |
		uint64_t(box[E::GetByte(c, 3)]) <<  8 |
		uint64_t(box[E::GetByte(c, 2)]);
	d = uint64_t(box[E::GetByte(d, 3)]) << 48 |
		uint64_t(box[E::GetByte(d, 2)]) << 40 |
		uint64_t(box[E::GetByte(d, 1)]) << 32 |
		uint64_t(box[E::GetByte(d, 0)]) << 24 |
		uint64_t(box[E::GetByte(d, 6)]) << 16 |
		uint64_t(box[E::GetByte(d, 5)]) <<  8 |
		uint64_t(box[E::GetByte(d, 4)]);

	state[0] = a;
	state[1] = b;
	state[2] = c;
	state[3] = d;
}

void drew::Rijndael256::Modify(uint64_t *state, const uint8_t *box)
{
	uint64_t a = state[0], b = state[1], c = state[2], d = state[3];

	a = uint64_t(box[E::GetByte(a, 7)]) << 56 |
		uint64_t(box[E::GetByte(a, 6)]) << 48 |
		uint64_t(box[E::GetByte(a, 5)]) << 40 |
		uint64_t(box[E::GetByte(a, 4)]) << 32 |
		uint64_t(box[E::GetByte(a, 3)]) << 24 |
		uint64_t(box[E::GetByte(a, 2)]) << 16 |
		uint64_t(box[E::GetByte(a, 1)]) <<  8 |
		uint64_t(box[E::GetByte(a, 0)]);
	b = uint64_t(box[E::GetByte(b, 0)]) << 56 |
		uint64_t(box[E::GetByte(b, 7)]) << 48 |
		uint64_t(box[E::GetByte(b, 6)]) << 40 |
		uint64_t(box[E::GetByte(b, 5)]) << 32 |
		uint64_t(box[E::GetByte(b, 4)]) << 24 |
		uint64_t(box[E::GetByte(b, 3)]) << 16 |
		uint64_t(box[E::GetByte(b, 2)]) <<  8 |
		uint64_t(box[E::GetByte(b, 1)]);
	c = uint64_t(box[E::GetByte(c, 2)]) << 56 |
		uint64_t(box[E::GetByte(c, 1)]) << 48 |
		uint64_t(box[E::GetByte(c, 0)]) << 40 |
		uint64_t(box[E::GetByte(c, 7)]) << 32 |
		uint64_t(box[E::GetByte(c, 6)]) << 24 |
		uint64_t(box[E::GetByte(c, 5)]) << 16 |
		uint64_t(box[E::GetByte(c, 4)]) <<  8 |
		uint64_t(box[E::GetByte(c, 3)]);
	d = uint64_t(box[E::GetByte(d, 3)]) << 56 |
		uint64_t(box[E::GetByte(d, 2)]) << 48 |
		uint64_t(box[E::GetByte(d, 1)]) << 40 |
		uint64_t(box[E::GetByte(d, 0)]) << 32 |
		uint64_t(box[E::GetByte(d, 7)]) << 24 |
		uint64_t(box[E::GetByte(d, 6)]) << 16 |
		uint64_t(box[E::GetByte(d, 5)]) <<  8 |
		uint64_t(box[E::GetByte(d, 4)]);

	state[0] = a;
	state[1] = b;
	state[2] = c;
	state[3] = d;
}

template<unsigned N>
void drew::GenericRijndael<N>::MixColumn(uint64_t *state)
{
	uint64_t r0 = 0, r1 = 0, r2 = 0, r3 = 0;

	for (int i = m_nb-1; i >= 0; i--) {
		uint8_t a0 = E::GetByte(state[0], i);
		uint8_t a1 = E::GetByte(state[1], i);
		uint8_t a2 = E::GetByte(state[2], i);
		uint8_t a3 = E::GetByte(state[3], i);

		r0 <<= 8;
		r1 <<= 8;
		r2 <<= 8;
		r3 <<= 8;

		r0 |= mult2[a0] ^ mult3[a1] ^ a2 ^ a3;
		r1 |= mult2[a1] ^ mult3[a2] ^ a3 ^ a0;
		r2 |= mult2[a2] ^ mult3[a3] ^ a0 ^ a1;
		r3 |= mult2[a3] ^ mult3[a0] ^ a1 ^ a2;
	}

	state[0] = r0;
	state[1] = r1;
	state[2] = r2;
	state[3] = r3;
}

template<unsigned N>
void drew::GenericRijndael<N>::InvMixColumn(uint64_t *state)
{
	uint64_t r0 = 0, r1 = 0, r2 = 0, r3 = 0;

	for (size_t i = 0; i < m_bc; i += 8)
	{
		uint8_t a0 = uint8_t(state[0] >> i);
		uint8_t a1 = uint8_t(state[1] >> i);
		uint8_t a2 = uint8_t(state[2] >> i);
		uint8_t a3 = uint8_t(state[3] >> i);

		r0 |= uint64_t(multe[a0] ^ multb[a1] ^ multd[a2] ^ mult9[a3]) << i;
		r1 |= uint64_t(multe[a1] ^ multb[a2] ^ multd[a3] ^ mult9[a0]) << i;
		r2 |= uint64_t(multe[a2] ^ multb[a3] ^ multd[a0] ^ mult9[a1]) << i;
		r3 |= uint64_t(multe[a3] ^ multb[a0] ^ multd[a1] ^ mult9[a2]) << i;
	}

	state[0] = r0;
	state[1] = r1;
	state[2] = r2;
	state[3] = r3;
}

void drew::Rijndael128::Round(uint8_t *obuf, const uint8_t *buf,
		const uint8_t *rk, const uint8_t *box)
{
	uint8_t a, b, c, d;
	a = box[buf[12] ^ rk[ 4]];
	b = box[buf[ 1] ^ rk[15]];
	c = box[buf[ 6] ^ rk[22]];
	d = box[buf[11] ^ rk[29]];
	obuf[12] = mult2[a] ^ mult3[b] ^ c ^ d;
	obuf[13] = mult2[b] ^ mult3[c] ^ d ^ a;
	obuf[14] = mult2[c] ^ mult3[d] ^ a ^ b;
	obuf[15] = mult2[d] ^ mult3[a] ^ b ^ c;

	a = box[buf[ 8] ^ rk[ 5]];
	b = box[buf[13] ^ rk[12]];
	c = box[buf[ 2] ^ rk[23]];
	d = box[buf[ 7] ^ rk[30]];
	obuf[ 8] = mult2[a] ^ mult3[b] ^ c ^ d;
	obuf[ 9] = mult2[b] ^ mult3[c] ^ d ^ a;
	obuf[10] = mult2[c] ^ mult3[d] ^ a ^ b;
	obuf[11] = mult2[d] ^ mult3[a] ^ b ^ c;

	a = box[buf[ 4] ^ rk[ 6]];
	b = box[buf[ 9] ^ rk[13]];
	c = box[buf[14] ^ rk[20]];
	d = box[buf[ 3] ^ rk[31]];
	obuf[ 4] = mult2[a] ^ mult3[b] ^ c ^ d;
	obuf[ 5] = mult2[b] ^ mult3[c] ^ d ^ a;
	obuf[ 6] = mult2[c] ^ mult3[d] ^ a ^ b;
	obuf[ 7] = mult2[d] ^ mult3[a] ^ b ^ c;

	a = box[buf[ 0] ^ rk[ 7]];
	b = box[buf[ 5] ^ rk[14]];
	c = box[buf[10] ^ rk[21]];
	d = box[buf[15] ^ rk[28]];
	obuf[ 0] = mult2[a] ^ mult3[b] ^ c ^ d;
	obuf[ 1] = mult2[b] ^ mult3[c] ^ d ^ a;
	obuf[ 2] = mult2[c] ^ mult3[d] ^ a ^ b;
	obuf[ 3] = mult2[d] ^ mult3[a] ^ b ^ c;
}

#define R128F(x, z, y, w) obuf[x] = box[buf[y] ^ rk[w]] ^ rk[z+32]

void drew::Rijndael128::Final(uint8_t *obuf, uint8_t *buf, const uint8_t *rk,
		const uint8_t *box)
{
	R128F(12,  4, 12,  4);
	R128F(13, 12,  1, 15);
	R128F(14, 20,  6, 22);
	R128F(15, 28, 11, 29);

	R128F( 8,  5,  8,  5);
	R128F( 9, 13, 13, 12);
	R128F(10, 21,  2, 23);
	R128F(11, 29,  7, 30);

	R128F( 4,  6,  4,  6);
	R128F( 5, 14,  9, 13);
	R128F( 6, 22, 14, 20);
	R128F( 7, 30,  3, 31);

	R128F( 0,  7,  0,  7);
	R128F( 1, 15,  5, 14);
	R128F( 2, 23, 10, 21);
	R128F( 3, 31, 15, 28);
}

void drew::Rijndael128::EncryptBlock(uint8_t *state)
{
	const size_t rksz = sizeof(uint64_t) * 4;
	uint8_t buf[sizeof(uint64_t) * 4];
	uint8_t *rk = m_rkb;
	uint8_t *p = state, *q = buf;

	for (size_t i = 0; i < m_nr-1; i++, rk += rksz) {
		Round(q, p, rk, S);
		std::swap(p, q);
	}

	Final(q, p, rk, S);
	if (q != state)
		memcpy(state, q, block_size);
}

void drew::Rijndael::EncryptBlock(uint64_t *state)
{
	for (size_t i = 0; i < m_nr-1; i++) {
		Round(state, m_rk[i], S);
	}

	KeyAddition(state, m_rk[m_nr-1]);
	Modify(state, S);
	KeyAddition(state, m_rk[m_nr]);
}

void drew::Rijndael::DecryptBlock(uint64_t *state)
{
	KeyAddition(state, m_rk[m_nr]);
	Substitution(state, Si);
	ShiftRow(state, m_sh1);

	for (size_t i = m_nr-1; i > 0; i--) {
		KeyAddition(state, m_rk[i]);
		InvMixColumn(state);
		Substitution(state, Si);
		ShiftRow(state, m_sh1);
	}

	KeyAddition(state, m_rk[0]);
}

template<unsigned N>
void drew::GenericRijndael<N>::PackBlock(uint8_t *blk, const uint64_t *state)
{
	for (size_t j = 0; j != m_bc; j += 8) {
		*blk++ = state[0] >> j;
		*blk++ = state[1] >> j;
		*blk++ = state[2] >> j;
		*blk++ = state[3] >> j;
	}
}

template<unsigned N>
void drew::GenericRijndael<N>::UnpackBlock(uint64_t *state, const uint8_t *blk)
{
	state[0] = *blk++;
	state[1] = *blk++;
	state[2] = *blk++;
	state[3] = *blk++;

	for (size_t j = 8; j != m_bc; j += 8) {
		state[0] |= uint64_t(*blk++) << j;
		state[1] |= uint64_t(*blk++) << j;
		state[2] |= uint64_t(*blk++) << j;
		state[3] |= uint64_t(*blk++) << j;
	}
}

const uint8_t drew::Rijndael::mult2[] = {
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 
	0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e, 
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 
	0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 
	0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 
	0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 
	0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e, 
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 
	0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 
	0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 
	0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 
	0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05, 
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 
	0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25, 
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 
	0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45, 
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 
	0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65, 
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 
	0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85, 
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 
	0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5, 
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 
	0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5, 
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 
	0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5, 
};

const uint8_t drew::Rijndael::mult3[] = {
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 
	0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11, 
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 
	0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21, 
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 
	0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71, 
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 
	0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41, 
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 
	0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1, 
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 
	0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1, 
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 
	0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1, 
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 
	0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81, 
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 
	0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a, 
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 
	0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba, 
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 
	0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea, 
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 
	0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda, 
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 
	0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a, 
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 
	0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a, 
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 
	0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a, 
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 
	0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a, 
};

const uint8_t drew::Rijndael::mult9[] = {
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 
	0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77, 
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 
	0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7, 
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 
	0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c, 
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 
	0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc, 
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 
	0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01, 
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 
	0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91, 
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 
	0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a, 
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 
	0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa, 
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 
	0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b, 
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 
	0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b, 
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 
	0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0, 
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 
	0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30, 
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 
	0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed, 
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 
	0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d, 
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 
	0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6, 
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 
	0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46, 
};

const uint8_t drew::Rijndael::multb[] = {
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 
	0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69, 
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 
	0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9, 
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 
	0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12, 
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 
	0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2, 
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 
	0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f, 
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 
	0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f, 
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 
	0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4, 
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 
	0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54, 
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 
	0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e, 
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 
	0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e, 
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 
	0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5, 
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 
	0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55, 
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 
	0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68, 
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 
	0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8, 
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 
	0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13, 
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 
	0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3, 
};

const uint8_t drew::Rijndael::multd[] = {
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 
	0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b, 
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 
	0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b, 
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 
	0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0, 
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 
	0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20, 
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 
	0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26, 
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 
	0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6, 
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 
	0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d, 
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 
	0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d, 
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 
	0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91, 
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 
	0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41, 
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 
	0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a, 
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 
	0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa, 
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 
	0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc, 
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 
	0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c, 
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 
	0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47, 
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 
	0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97, 
};

const uint8_t drew::Rijndael::multe[] = {
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 
	0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a, 
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 
	0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba, 
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 
	0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81, 
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 
	0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61, 
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 
	0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7, 
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 
	0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17, 
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 
	0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c, 
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 
	0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc, 
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 
	0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b, 
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 
	0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb, 
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 
	0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0, 
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 
	0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20, 
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 
	0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6, 
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 
	0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56, 
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 
	0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d, 
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 
	0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d, 
};

const uint8_t drew::Rijndael::S[] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
};

const uint8_t drew::Rijndael::Si[] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
	0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
	0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
	0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
	0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
	0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
	0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d,
};

const uint8_t drew::Rijndael::rcon[] = {
	0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91
};
